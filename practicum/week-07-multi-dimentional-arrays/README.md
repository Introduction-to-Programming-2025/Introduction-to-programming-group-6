# Седмица 7 - Многомерни масиви

[Github assignment](https://classroom.github.com/a/n2QUXSO7)

```c
// създаване
int arr[2][3] {{1,2,3} ,{4,5,6}}
// Обхождане по редове
for(int i=0; i<2; i++)
    for(int j=0; j<3; j++)
        std::cout << arr[i][j] << " ";
```

```c
int* flat = &arr[0][0];
for(int i=0; i<rows*cols; i++){
    std::cout << flat[i] << " ";
}
```

```c
// Обхождане по колони
for(int j=0; j < col; j++)
    for(int i = 0; i < row; i++)
        std::cout << arr[i][j] << " ";
```

```c
void f1(int arr[][MAX_COL], size_t n, size_t m)...
// Защо можем да изпуснем първия, а другите са задължителни
```

```c
// Какво ще изведе?
int a[3][4];
std::cout << sizeof(g)/sizeof(а[0]);
std::cout << sizeof(g)/sizeof(а[0][0]);
std::cout << sizeof(a[0])/sizeof(a[0][0]);
// Да не се използва когато масива е подаден във функция
```

### Задача 1

Да се напише функция, която намира максималния елемент, който се намира на главния или вторичния диагонал

```c
IN:
2 9 1 7
1 6 5 9
8 3 4 11
12 4 5 -5
OUT: 12
```

### Задача 2

Дадена е матрица, да се завърти на 90 градуса.

```
IN:
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
OUT:
 13 9 5 1
 14 10 6 2
 15 11 7 3
 16 12 8 4
```

### Задача 3

Напишете функция, която при дадена матрица намира реда с максимална сума и го премества на първи ред.

```c
IN:
3 17 5 12 -> 37
8  1 14 7 -> 30
10 6 2 19 -> 37
4 15 11 9 -> 39
OUT:
4 15 11 9
8 1 14 7
10 6 2 19
3 17 5 12
```

### Задача 4

Напишете функция, която сортира колоните на дадена по тяхната сума по низходящ ред.

```c
IN:
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
OUT:
4 3 2 1
8 7 6 5
12 11 10 9
16 15 14 13
```

### Задача 5

**Conway's Game of Life:**
Дадена е матрица, където всяка клетка има състояние жива или умряла.
На всяко поколение действат ЕДНОВРЕМЕННО следните правила:

- Самота - жива клетка умира, ако има по-малко от два живи съседа.
- Пренаселване - жива клетка умира, ако има повече от три живи съседа.
- Благоприятна среда - жива клетка продължава да живее, ако има 2 или 3 съседа.
- Раждане - Мъртва клетка оживява, ако има точно 3 живи съседа.
  Да се реализира функция, която играе играта като приема като аргумент финалното поколение.
- Да се реализира функция, която изиграва n цикъла по дадено начално поле.
  Забележка: решението да не ползва помощен масив.
  [За повече информация](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)

![glider_gun](https://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif)

<details>
<summary>НАТИСНИ ЗА ПРИМЕРЕН ВХОД/ИЗХОД</summary>

```c
gen:8
In: int matrix[10][10] = {
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 1, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 1, 1, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
Out:
GEN: 1:
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 0 0 0 0 0
0 0 0 1 0 0 0 0 0 0
0 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
----
----
GEN: 2:
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 0 0 0 0 0
0 0 1 0 0 1 0 0 0 0
0 0 0 1 1 0 0 0 0 0
0 0 0 0 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
----
----
GEN: 3:
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 0 0 0 0 0
0 0 1 0 0 1 0 0 0 0
0 0 0 1 1 1 0 0 0 0
0 0 0 1 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
----
----
GEN: 4:
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 0 0 0 0 0
0 0 1 0 0 1 0 0 0 0
0 0 1 0 0 1 0 0 0 0
0 0 0 1 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
----
----
GEN: 5:
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 0 0 0 0 0
0 0 1 0 0 1 0 0 0 0
0 0 1 1 0 1 1 0 0 0
0 0 0 0 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
----
----
GEN: 6:
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 0 0 0 0 0
0 0 1 0 0 1 1 0 0 0
0 0 1 1 0 1 1 0 0 0
0 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
----
----
GEN: 7:
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 1 0 0 0 0
0 0 1 0 0 0 1 0 0 0
0 0 1 0 0 0 0 0 0 0
0 0 1 1 0 1 1 0 0 0
0 0 0 0 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
----
----
GEN: 8:
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0 0
0 0 0 1 1 1 0 0 0 0
0 0 1 0 1 1 0 0 0 0
0 1 1 0 0 1 1 0 0 0
0 0 1 1 1 1 0 0 0 0
0 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
----
```

</details>

### Задача 6

Да се напише функция която генерира масив, който всеки елемент от всеки "слой", да са номера на слоя.

```
matrixNxMLayers(array, 7, 8);
1 1 1 1 1 1 1 1
1 2 2 2 2 2 2 1
1 2 3 3 3 3 2 1
1 2 3 4 4 3 2 1
1 2 3 3 3 3 2 1
1 2 2 2 2 2 2 1
1 1 1 1 1 1 1 1
```

### Задача 7

Да се направи функция която приема матрица и числа m и n - по малки от размера на масива. Да се намери максималната сума на подматрица на оригиналната с размери m и n.

```c
IN:
1 2 0 3 4 1
0 1 5 2 1 0
4 1 0 3 2 2
2 0 3 1 0 1
1 3 2 4 1 0
15
```

### Задача 8

Направете функция, която прави K на брой циклични завъртания надясно на колоните, след което reverse-ва колоните на нечетна позиция.

```c
IN:
- завъртане k == 1
 1   2   3   4   5
 6   7   8   9  10
11  12  13  14  15
16  17  18  19  20

OUT:
5 16 2 18 4
10 11 7 13 9
15 6 12 8 14
20 1 17 3 19
```

```

```
