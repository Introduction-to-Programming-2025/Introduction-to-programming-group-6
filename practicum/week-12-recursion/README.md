## Седмица 12 - Рекурсия

[[Github assignment]](https://classroom.github.com/a/xhh6oYNr)

##### Елементи на рекурсивна функция

1. Дъно на рекурсията - базов случай където рекурсивните извиквания спират.
2. Рекурсивно извикване - извикване на същата функция **с променено състояние** (иначе дъното никога няма да бъде достигнато)

---

##### Каква е разликата?

```c
int fib1(int n)
{
    if (n == 1 || n == 2)
    {
        return 1;
    }
    return fib1(n - 1) + fib1(n - 2);
}

int fib2Helper(int n, int f1, int f2)
{
    if (n == 1 || n == 2)
    {
        return f1;
    }
    return fib2Helper(n - 1, f1 + f2, f1);
}
int fib2(int n)
{
    return fib2Helper(n, 1, 1);
}
```

## Задачи

---

### Задача 1

Функция, която рекурсивно намира сумата от първите n естествени числа

---

### Задача 2

Намерете НОД на две числа, използвайки алгоритъма на Евклид:
Алгоритъмът на Евклид намира най-големия общ делител на две числа, като последователно заменя по-голямото число с остатъка от делението му на по-малкото, докато остатъкът стане нула.

---

### Задача 3

Функция, която обръща число използвайки рекурсия.

---

### Задача 4

Рекурсивна функция, която приема сортиран масив и число и добавя числото на правилната позиция.

---

### Задача 5

Функция, която намира по колко начина може да се изкачи стълбище с брой на стълбите `n` и с възможни стъпки по 1, 2 или 3 стъпала на стъпка (за 0 приемаме, че има един начин).

```cpp
10 -> 274
```

---

### Задача 6

Функция, която проверява дали низ е почти палиндром - или е палиндром или е палиндром ако се премахне най-много два символа

```cpp
"abccdcbba" -> True
"abccdcbbaa" -> False
```

---

### Задача 7

Функция, която генерира всички бинарни низове с дължина `n`, които не съдържат последователни единици.

```cpp
n = 4
0000
0001
0010
0100
0101
1000
1001
1010
```

---

### Задача 8

Рекурсивна функция, която принтира всички суми, които дават n (цяло положително число).

```cpp
n = 4
OUT:
4
3 1
2 2
2 1 1
1 1 1 1
```

---

### Задача 9

Разполагате с раница с максимална вместимост тегло `W` което може да понесе преди да се скъса. Разполагате и с n скъпоценни камъни, като за всеки предмет `i` разполагате с теглото му `w[i]` и стойността му `v[i]`. Да се изведе максималната стойност на предметите без да се надвишава теглото `W`.

```cpp
values = {1, 2, 3}
weights = {4, 5, 1}
W = 4
OUTPUT -> 3
```
